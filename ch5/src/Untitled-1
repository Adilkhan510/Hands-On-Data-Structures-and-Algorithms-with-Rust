# B Trees




## A Device Database

## 

## A Device Database

# Graphs

In their most generic form, trees are graphs - directed, acyclic graphs. A general graph can be described as a collection of connected nodes, sometimes referred to as vertices, with certain properties like whether cycles are allowed. The connections between those also have their own name: edges. These edges can have certain properties as well, in particular weights and directions (like one-way streets).

By enforcing these constraints, a model can be built that - just like trees - reflect a certain reality very well. There is one particular thing that is typically represented as a weighted graph: the Internet. While nowadays this might be an oversimplification with various versions of the internet protocol (IPv4 and IPv6) and network address translation technologies (NAT) hiding large parts of participants online. In its earlier days however, the internet can be shown as a collection of routers, computers, and servers (nodes) interconnected with links (edges) defined by speed and latency (weights).

!# Image: Internet

Other than humans, who can typically see and follow a reasonably efficient path through this mesh of interconnected nodes, computers require specific instructions to find anything in there! This called for new algorithms that allow for dealing with this complexity - which is especially tricky once the number of nodes in the mesh exceeds the number of nodes that can be looked at in time. This led to the development of many routing algorithms, techniques to finding cycles and segmenting the network, or popular NP-hard problems like the traveling salesman problem or the graph-coloring problem. 

!# image: TSP 

Today there are many examples of graphs, the most obvious being a social graph (in social networks), but also as part of Tensorflow's deep learning API, state machines, and the rise of graph databases that offer a generic query language to traverse graphs. Even some less obvious use cases can be found like storing genetic sequences (nodes being the small parts of the DNA)! 

To get out of theoretical constructs, how would you represent a graph in a program _efficiently_? As a node struct with a list of outbound vertices? How would you find a particular node then? A tricky problem! Graphs also have the habit of growing quite large, as anyone who ever wanted to serialize object graphs to JSON can testify: they run out of memory quite easily. 

The best way to work with this data structure is surprisingly simple: a matrix. This matrix can either be sparse (i.e. a list of lists with varying sizes), called an adjacency list, or full-blown matrix (adjacency matrix). Especially for a matrix, the size is typically the number of nodes on either side and the weights (or boolean values representing "connected or not") at each crossing. Many implementations will also keep the "real" nodes in its own list, using the indices as ids.

!# image: matrix vs graph

Rust provides many great tools for implementing really complex graph structures: enums and pattern matching provide ways to operate on types of nodes and edges with low overhead, iterators and functional approaches remove the need for verbose loops. Let's look at a generic graph struct in Rust:

!# code: simple Graph structure in Rust, adjacency list

This adjacency list can store nodes and whether they are connected, making this a finite, indirected, unweighted graph - great for storing simple relationships between objects. Already, a data structure like this has the ability to implement sophisticated routing algorithms or run out of resources on a backtracking algorithm. In an adjacency list, each index in the list represents the origin of an edge and the contained elements (also lists) are any outbound edges. To traverse the graph, start at an origin index and find the next index by searching its edges. Then repeat until arriving at the destination node!

When the product team has heard of this amazing data structure - and they are now well aware of your abilities - they came up with a new product: the literal Internet Of Things (it's a working title). Their idea is to provide customers with a way to model complex sensor placements that would have distance built in! Customers can then go and evaluate all sensors that are within a certain range of each other, find single points of failure, or plan a route to inspect them quickly. To summarize, customers should be able to:

- Create add a list of nodes
- Connect nodes with their physical distance to each other
- Find the shortest path between two nodes with respect to the distance provided
- Retrieve a list of neighbors up to a certian degree

Great idea, right? A great fit for graphs as well. 


## The Literal Internet Of Things

The envisioned product 

# Summary

# Questions